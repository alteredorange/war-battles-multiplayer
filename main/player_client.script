--#IF HEADLESS
local should_send = false
--#ELSE
local should_send = true
--#ENDIF

-- 
-- local client = socket.tcp()
-- client:connect("127.0.0.1", 8190)
-- client:settimeout(0)

local tcp_client = require "defnet.tcp_client"
local IP = "127.0.0.1" 
local PORT = 7777
local id = rnd.range(1000, 9999)
local players = {}

-- Server address and port
local server_address = "127.0.0.1"
local server_port = 5555

-- UDP Stuff
-- local ip, port = 127.0.0.1, 5555
-- local host, port = "localhost", 13
-- local socket = require("socket")
-- convert host name to ip address
-- local ip = assert(socket.dns.toip(host))
-- create a new UDP object

udp = socket.udp()
udp:settimeout(0)

-- client:settimeout(0)


function init(self)

	-- camera.acquire_focus("camera#camera")
	-- self.client = client:connect(IP, PORT)
	-- client:settimeout(0)
	-- print(self.client)
	-- client:settimeout(0)


	-- self.client = tcp_client.create(IP, PORT, function(data)
	-- 	print("TCP client received data " .. data)
	-- end,
	-- function()
	-- 	print("On disconnected")
	-- 	self.client = nil
	-- end)
	

	-- client:send('{"u":1}\n')
	
	-- msg.post(".", "acquire_input_focus")            -- [2]

	self.moving = false          
	self.firing = false    		                   -- [3]
	self.input = vmath.vector3()                    -- [4]
	self.dir = vmath.vector3(0, 1, 0)               -- [5]
	self.speed = 400             

	-- correction vector
	self.correction = vmath.vector3()         

	-- create a new player instance
	local player_instance = {
		moving = self.moving,
		firing = self.firing,
		input = self.input,
		dir = self.dir,
		speed = self.speed,
		correction = self.correction
	}

	-- store the player instance with the unique id
	players[id] = player_instance

	
end

function final(self)                                -- [7]
	msg.post(".", "release_input_focus")   
	if self.client then
		self.client.destroy()
	end
	udp:close()
end

function update(self, dt)    
	local player = players[id]
	if player then

	-- contact daytime host
	-- udp:send("anything")

	-- if self.client then
	-- 	self.client.update()
	-- end

	-- client:send('{"hii":1}\n')
	
	-- local response = client:receive("*l")

	if response then
		res = json.decode(response)
		print(response)
		-- Parse the JSON response
		

		-- Update the player's speed and other stats
		if res.speed then
			self.speed = res.speed
		end
	end
	-- print ("hi")
	
	-- print(err)
	


	-- reset correction
	player.correction = vmath.vector3()

	     
	update_animation(self, player)                 
	if player.moving then
		local pos = go.get_position()
		pos = pos + player.dir * player.speed * dt
		go.set_position(pos)
	end

	if player.firing then
		local angle = math.atan2(player.dir.y, player.dir.x)
		local rot = vmath.quat_rotation_z(angle)
		local props = { dir = player.dir }
		factory.create("#rocketfactory", nil, rot, props)
	end

	player.input.x = 0
	player.input.y = 0

	player.moving = false
	player.firing = false
end
end

function update_animation(self, player)
	local anim_dir = vmath.vector3(player.input.x, player.input.y, 0)

	if anim_dir ~= self.anim_dir then
		if self.anim_id ~= nil then
			sprite.stop_animation(self.anim_id)
			self.anim_id = nil
		end

		if vmath.length(anim_dir) > 0 then
			local anim_name
			if anim_dir.x > 0 then
				anim_name = "player-right"
			elseif anim_dir.x < 0 then
				anim_name = "player-left"
			elseif anim_dir.y > 0 then
				anim_name = "player-up"
			elseif anim_dir.y < 0 then
				anim_name = "player-down"
			else
				anim_name = "player-idle"
			end
			sprite.play_flipbook("#sprite", anim_name)
		end

		self.anim_dir = anim_dir
	end
end

function on_input(self, action_id, action) 


	-- defnet client         
-- 	local client, err = tcp_client.create(IP, PORT,
-- 	function(data)
-- 		print(data)
-- 	end,
-- 	function()
-- 		self.client = nil
-- 	end)
-- 
-- 	if client then
-- 		self.client = client
-- 	else
-- 		print(err)
-- 	end
local player = players[id]
if player then
	
	if action_id == hash("up") then
		player.input.y = 1
	elseif action_id == hash("down") then
		player.input.y = -1
	elseif action_id == hash("left") then
		player.input.x = -1
	elseif action_id == hash("right") then
		player.input.x = 1
	elseif action_id == hash("fire") and action.pressed then
		player.firing = true
	end

	if vmath.length(player.input) > 0 then
		-- print(self.input)
		
		-- defnet send message	
		-- self.client.send(self.input.x .. "," .. self.input.y .. "\n")

	

		
		-- Construct the movement data message
		-- local message = string.format("%.2f,%.2f,%.2f,%.2f,%.2f,%.2f", position.x, position.y, position.z, rotation.x, rotation.y, rotation.z)

		-- Send the movement data to the server
		if should_send then
			local pos = go.get_position()
			local message = id .. "*" .. self.input.x .. "*" .. self.input.y .. "*" .. pos
			udp:sendto(message, server_address, server_port)
		end

		
		-- self.client.send("hi")	-- defnet send message	
		-- self.client.send("going up!\n")
		
		
		player.moving = true                          -- [16]
		player.dir = vmath.normalize(player.input)      -- [17]
		-- print(self.dir)
	end
	end
end



function on_message(self, message_id, message, sender)
	local player = players[id]
	if player then
	-- Handle collision
	-- https://defold.com/manuals/physics-resolving-collisions/
	if message_id == hash("contact_point_response") then
		-- Get the info needed to move out of collision. We might
		-- get several contact points back and have to calculate
		-- how to move out of all of them by accumulating a
		-- correction vector for this frame:
		if message.distance > 0 then
			-- First, project the accumulated correction onto
			-- the penetration vector
			local proj = vmath.project(player.correction, message.normal * message.distance)
			if proj < 1 then
				-- Only care for projections that does not overshoot.
				local comp = (message.distance - message.distance * proj) * message.normal
				-- Apply compensation
				go.set_position(go.get_position() + comp)
				-- Accumulate correction done
				player.correction = player.correction + comp
			end
		end
	end

end

-- if message_id == hash("collision_response") then 
-- 	print("collided!") -- <4>
-- 	if message.own_group == hash("danger") then  -- <5>
-- 		go.delete(message.other_id)  -- <6>
-- 	end
-- end
end